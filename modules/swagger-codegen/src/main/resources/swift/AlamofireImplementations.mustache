// AlamofireImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire

public class AlamofireRequestBuilderFactory: RequestBuilderFactory {
    public static var bodyParameterEncoding = Alamofire.ParameterEncoding.JSON
    public static var contentSerializers: [String: ResponseSerializer<AnyObject, NSError>] = [
        "application/json":Request.JSONResponseSerializer(options: .AllowFragments),
        ]

    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return AlamofireRequestBuilder<T>.self
    }
}

// Store manager to retain its reference
private var managerStore: [String: Alamofire.Manager] = [:]

enum RequestHandlerError:ErrorType {
    case Message(_:String)
}

class AlamofireRequestBuilder<T>: RequestBuilder<T> {
    required init(method: String, URLString: String, parameters: [String : AnyObject]?, isBody: Bool) {
        super.init(method: method, URLString: URLString, parameters: parameters, isBody: isBody)
    }

    override func execute(completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        let managerId = NSUUID().UUIDString
        // Create a new manager for each request to customize its request header
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = buildHeaders()
        let manager = Alamofire.Manager(configuration: configuration)
        managerStore[managerId] = manager

        let encoding = isBody ? AlamofireRequestBuilderFactory.bodyParameterEncoding : Alamofire.ParameterEncoding.URL
        let xMethod = Alamofire.Method(rawValue: method)
        let fileKeys = parameters == nil ? [] : parameters!.filter { $1.isKindOfClass(NSURL) }
                                                           .map { $0.0 }

        if fileKeys.count > 0 {
            manager.upload(
                xMethod!, URLString, headers: nil,
                multipartFormData: { mpForm in
                    for (k, v) in self.parameters! {
                        switch v {
                        case let fileURL as NSURL:
                            mpForm.appendBodyPart(fileURL: fileURL, name: k)
                            break
                        case let string as NSString:
                            mpForm.appendBodyPart(data: string.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        case let number as NSNumber:
                            mpForm.appendBodyPart(data: number.stringValue.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        default:
                            fatalError("Unprocessable value \(v) with key \(k)")
                            break
                        }
                    }
                },
                encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold,
                encodingCompletion: { encodingResult in
                    switch encodingResult {
                    case .Success(let uploadRequest, _, _):
                        if let onProgressReady = self.onProgressReady {
                            onProgressReady(uploadRequest.progress)
                        }
                        self.processRequest(uploadRequest, managerId, completion)
                    case .Failure(let encodingError):
                        completion(response: nil, error: ErrorResponse.Error(415, nil, encodingError))
                    }
                }
            )
        } else {
            let request = manager.request(xMethod!, URLString, parameters: parameters, encoding: encoding)
            if let onProgressReady = self.onProgressReady {
                onProgressReady(request.progress)
            }
            processRequest(request, managerId, completion)
        }

    }
    
    // returns a serializer that can interpret response data without a provided Content-Type
    static func UnknownResponseSerializer() -> ResponseSerializer<AnyObject, NSError>
    {
        return ResponseSerializer { request, response, data, error in
            guard error == nil else { return .Failure(error!) }
            
            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
            
            switch T.self {
                
            case is String.Type:
                // use the stringResponseSerializer to parse data
                let result = Request.stringResponseSerializer().serializeResponse(request, response, data, error).value ?? ""
                return .Success(result)
                
            case is Void.Type:
                // always return nil
                return .Success(NSNull())
                
            case is NSData.Type:
                // already is a NSData, pass it through
                return .Success(data as! AnyObject)
                
            default:
                return .Failure(RequestHandlerError.Message("Could not serialize unknown Content-Type") as NSError)
            }
        }
    }

    private func processRequest(request: Request, _ managerId: String, _ completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        if let credential = self.credential {
            request.authenticate(usingCredential: credential)
        }
        
        request.validate().response { (request:NSURLRequest?, response:NSHTTPURLResponse?, data:NSData?, error:NSError?) in

            // remove the manager from the store
            managerStore.removeValueForKey(managerId)

            do {
                guard error == nil else {
                    // was a error throw it to the catch
                    throw error!
                }
            
                // use the UnknownResponseSerializer as the default serializer
                var responseSerializer = AlamofireRequestBuilder.UnknownResponseSerializer()
                
                // decode before setting body of response
                var decodeSerializedResponse = false
                
                if let contentTypeString = response?.allHeaderFields["Content-Type"] as? String {
                    
                    // serialized responses need to be decoded afterwards
                    decodeSerializedResponse = true
                
                    // check to see if Content-Type is supported in the provided dictionary
                    guard let contentTypeSerializer = AlamofireRequestBuilderFactory.contentSerializers[contentTypeString] else {
                        throw RequestHandlerError.Message("Unhandled Content-Type \(contentTypeString)")
                    }
                    
                    responseSerializer = contentTypeSerializer
                }
                
                // serialize the response
                let serializedResponse = responseSerializer.serializeResponse(request, response, data, error)
                
                // if there is an error, throw it
                guard let value = serializedResponse.value else {
                    throw serializedResponse.error!
                }
                
                // decode the body if necessary
                let body = decodeSerializedResponse ? Decoders.decode(clazz: T.self, source: value) : (value as? T)
                
                // complete the request with the serialized body
                completion(response:Response(response: response!, body: body), error: nil)
                
            } catch {
                // there was an error, complete the request with the error attached
                return completion(response: nil, error: ErrorResponse.Error(response?.statusCode ?? 500, data, error))
            }
            
        }
    }

    private func buildHeaders() -> [String: AnyObject] {
        var httpHeaders = Manager.defaultHTTPHeaders
        for (key, value) in self.headers {
            httpHeaders[key] = value
        }
        return httpHeaders
    }
}
